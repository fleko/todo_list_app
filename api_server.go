package main

import (
	"fmt"
	"log"
	"net/http"

	"github.com/gorilla/mux"
)

// Task structure with id, name, and completion status
type Task struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Completed bool   `json:"completed"`
}

// global variables are bad, using them here for brevity

// list of tasks
var tasks []Task = []Task{}

/*
 TODO:
 Simple API for a TODO list with tasks
 - Each task can be created, deleted, and its completion status can be toggled
 - GET list of tasks (show ID[int], name[string], complete[bool])
 - GET specific task by ID (show ID, name, status)
 - POST create task (pass name only, incomplete by default, ID autogenerated random uuid)
 - PUT Toggle task completion by ID
 - DELETE task by ID
*/

func main() {
	// creates a new top level mux.Router. since a mux.Router implements the http.Handler interface,
	// we can pass it to http.ListenAndServe below
	router := mux.NewRouter()

	// configure the router to always run this handler when it couldn't match a request to any other handler
	router.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte(fmt.Sprintf("%s not found\n", r.URL)))
	})

	router.HandleFunc("/api/tasks", getTasks).Methods("GET")
	router.HandleFunc("/api/tasks/{id}", getTask).Methods("GET")

	router.HandleFunc("/api/tasks", createTask).Methods("POST")

	router.HandleFunc("/api/tasks/{id}", deleteTask).Methods("DELETE")

	router.HandleFunc("/api/tasks/{id}", toggleTaskStatus).Methods("PUT")

	log.Printf("serving on port 8080")
	http.ListenAndServe(":8080", router)
}
